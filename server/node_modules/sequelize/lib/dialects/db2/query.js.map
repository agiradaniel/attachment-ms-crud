{
  "version": 3,
  "sources": ["../../../src/dialects/db2/query.js"],
  "sourcesContent": ["'use strict';\n\nconst util = require('util');\n\nconst AbstractQuery = require('../abstract/query');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('db2');\nconst _ = require('lodash');\nconst { logger } = require('../../utils/logger');\nconst moment = require('moment');\nconst debug = logger.debugContext('sql:db2');\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'id';\n  }\n\n  getSQLTypeFromJsType(value) {\n    if (Buffer.isBuffer(value)) {\n      return { ParamType: 'INPUT', DataType: 'BLOB', Data: value };\n    }\n\n    if (typeof value === 'bigint') {\n      // The ibm_db module does not handle bigint, send as a string instead:\n      return value.toString();\n    }\n\n    return value;\n  }\n\n  async _run(connection, sql, parameters) {\n    this.sql = sql;\n    const benchmark = this.sequelize.options.benchmark || this.options.benchmark;\n    let queryBegin;\n    if (benchmark) {\n      queryBegin = Date.now();\n    } else {\n      this.sequelize.log(`Executing (${ this.connection.uuid || 'default' }): ${ this.sql}`, this.options);\n    }\n\n    const errStack = new Error().stack;\n\n    return new Promise((resolve, reject) => {\n      // TRANSACTION SUPPORT\n      if (_.startsWith(this.sql, 'BEGIN TRANSACTION')) {\n        connection.beginTransaction(err => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, 'COMMIT TRANSACTION')) {\n        connection.commitTransaction(err => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, 'ROLLBACK TRANSACTION')) {\n        connection.rollbackTransaction(err => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, 'SAVE TRANSACTION')) {\n        connection.commitTransaction(err => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            connection.beginTransaction(err => {\n              if (err) {\n                reject(this.formatError(err, errStack));\n              } else {\n                resolve(this.formatResults());\n              }\n            });\n          }\n        }, this.options.transaction.name);\n      } else {\n        const params = [];\n        if (parameters) {\n          _.forOwn(parameters, (value, key) => {\n            const param = this.getSQLTypeFromJsType(value, key);\n            params.push(param);\n          });\n        }\n        const SQL = this.sql.toUpperCase();\n        let newSql = this.sql;\n        if ((this.isSelectQuery() || _.startsWith(SQL, 'SELECT ')) &&\n            SQL.indexOf(' FROM ', 8) === -1 ) {\n          if (this.sql.charAt(this.sql.length - 1) === ';') {\n            newSql = this.sql.slice(0, this.sql.length - 1);\n          }\n          newSql += ' FROM SYSIBM.SYSDUMMY1;';\n        }\n\n        connection.prepare(newSql, (err, stmt) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          }\n\n          stmt.execute(params, (err, result, outparams) => {\n            debug(`executed(${this.connection.uuid || 'default'}):${newSql} ${parameters ? util.inspect(parameters, { compact: true, breakLength: Infinity }) : ''}`);\n\n            if (benchmark) {\n              this.sequelize.log(`Executed (${this.connection.uuid || 'default'}): ${newSql} ${parameters ? util.inspect(parameters, { compact: true, breakLength: Infinity }) : ''}`, Date.now() - queryBegin, this.options);\n            }\n\n            if (err && err.message) {\n              err = this.filterSQLError(err, this.sql, connection);\n              if (err === null) {\n                stmt.closeSync();\n                resolve(this.formatResults([], 0));\n              }\n            }\n            if (err) {\n              err.sql = sql;\n              stmt.closeSync();\n              reject(this.formatError(err, errStack, connection, parameters));\n            } else {\n              let data = [];\n              let metadata = [];\n              let affectedRows = 0;\n              if (typeof result === 'object') {\n                if (_.startsWith(this.sql, 'DELETE FROM ')) {\n                  affectedRows = result.getAffectedRowsSync();\n                } else {\n                  data = result.fetchAllSync();\n                  metadata = result.getColumnMetadataSync();\n                }\n                result.closeSync();\n              }\n              stmt.closeSync();\n              const datalen = data.length;\n              if (datalen > 0) {\n                const coltypes = {};\n                for (let i = 0; i < metadata.length; i++) {\n                  coltypes[metadata[i].SQL_DESC_NAME] =\n                      metadata[i].SQL_DESC_TYPE_NAME;\n                }\n                for (let i = 0; i < datalen; i++) {\n                  for (const column in data[i]) {\n                    const parse = parserStore.get(coltypes[column]);\n                    const value = data[i][column];\n                    if (value !== null) {\n                      if (parse) {\n                        data[i][column] = parse(value);\n                      } else if (coltypes[column] === 'TIMESTAMP') {\n                        data[i][column] = new Date(moment.utc(value));\n                      } else if (coltypes[column] === 'BLOB') {\n                        data[i][column] = new Buffer.from(value);\n                      } else if (coltypes[column].indexOf('FOR BIT DATA') > 0) {\n                        data[i][column] = new Buffer.from(value, 'hex');\n                      }\n                    }\n                  }\n                }\n                if (outparams && outparams.length) {\n                  data.unshift(outparams);\n                }\n                resolve(this.formatResults(data, datalen, metadata, connection));\n              } else {\n                resolve(this.formatResults(data, affectedRows));\n              }\n            }\n          });\n        });\n      }\n    });\n  }\n\n  async run(sql, parameters) {\n    return await this._run(this.connection, sql, parameters);\n  }\n\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam = {};\n    const replacementFunc = (match, key, values) => {\n      if (values[key] !== undefined) {\n        bindParam[key] = values[key];\n        return '?';\n      }\n      return undefined;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    if (Array.isArray(values) && typeof values[0] === 'object') {\n      bindParam = values;\n    }\n\n    return [sql, bindParam];\n  }\n\n  filterSQLError(err, sql, connection) {\n    if (err.message.search('SQL0204N') != -1 && _.startsWith(sql, 'DROP ')) {\n      err = null; // Ignore table not found error for drop table.\n    } else if (err.message.search('SQL0443N') != -1) {\n      if (this.isDropSchemaQuery()) {\n        // Delete ERRORSCHEMA.ERRORTABLE if it exist.\n        connection.querySync('DROP TABLE ERRORSCHEMA.ERRORTABLE;');\n        // Retry deleting the schema\n        connection.querySync(this.sql);\n      }\n      err = null; // Ignore drop schema error.\n    } else if (err.message.search('SQL0601N') != -1) {\n      const match = err.message.match(/SQL0601N {2}The name of the object to be created is identical to the existing name \"(.*)\" of type \"(.*)\"./);\n      if (match && match.length > 1 && match[2] === 'TABLE') {\n        let table;\n        const mtarray = match[1].split('.');\n        if (mtarray[1]) {\n          table = `\"${mtarray[0]}\".\"${mtarray[1]}\"`;\n        } else {\n          table = `\"${mtarray[0]}\"`;\n        }\n        if (connection.dropTable !== false) {\n          connection.querySync(`DROP TABLE ${table}`);\n          err = connection.querySync(sql);\n        }\n        else {\n          err = null;\n        }\n      } else {\n        err = null; // Ignore create schema error.\n      }\n    } else if (err.message.search('SQL0911N') != -1) {\n      if (err.message.search('Reason code \"2\"') != -1) {\n        err = null; // Ignore deadlock error due to program logic.\n      }\n    } else if (err.message.search('SQL0605W') != -1) {\n      err = null; // Ignore warning.\n    } else if (err.message.search('SQL0668N') != -1 &&\n      _.startsWith(sql, 'ALTER TABLE ')) {\n      connection.querySync(`CALL SYSPROC.ADMIN_CMD('REORG TABLE ${sql.substring(12).split(' ')[0]}')`);\n      err = connection.querySync(sql);\n    }\n    if (err && err.length === 0) { err = null; }\n    return err;\n  }\n\n  /**\n   * High level function that handles the results of a query execution.\n   *\n   *\n   * Example:\n   *  query.formatResults([\n   *    {\n   *      id: 1,              // this is from the main table\n   *      attr2: 'snafu',     // this is from the main table\n   *      Tasks.id: 1,        // this is from the associated table\n   *      Tasks.title: 'task' // this is from the associated table\n   *    }\n   *  ])\n   *\n   * @param {Array} data - The result of the query execution.\n   * @param {Integer} rowCount - The number of affected rows.\n   * @param {Array} metadata - Metadata of the returned result set.\n   * @param {object} conn - The connection object.\n   * @private\n   */\n  formatResults(data, rowCount, metadata, conn) {\n    let result = this.instance;\n    if (this.isInsertQuery(data, metadata)) {\n      this.handleInsertQuery(data, metadata);\n\n      if (!this.instance) {\n        if (this.options.plain) {\n          const record = data[0];\n          result = record[Object.keys(record)[0]];\n        } else {\n          result = data;\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      result = data;\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", '').replace(\"')\", '').replace(/'/g, '');\n        }\n\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === 'Y' ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.KeySeq > 0,\n          auto